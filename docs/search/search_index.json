{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"sokobanpy Documentation Sokoban in Python. Author: Quan Lin License: MIT What is Sokoban? Sokoban is a classic puzzle game where the player pushes boxes onto designated goal positions within a warehouse-like environment. The game is played on a grid, and each element is represented by a standard character: \"#\" : Wall \"@\" : Player (Sokoban) \"$\" : Box \".\" : Goal \"*\" : Box on a goal \"+\" : Player on a goal \" \" : Empty space Objective Move all boxes ( \"$\" ) onto the goal positions ( \".\" ) using the player ( \"@\" ). Boxes can only be pushed (not pulled), and only one box can be pushed at a time. The player cannot move through walls or boxes. How to play Use directional controls to move the player. Strategically plan moves to avoid pushing boxes into corners or against walls where they can't be retrieved. The puzzle is solved when all boxes are on goal tiles ( \"*\" ). Installation For CPython pip install sokobanpy For MicroPython If mpremote is not installed, install it first: pip install mpremote Install sokobanpy using mpremote : mpremote mip install github:jacklinquan/sokobanpy/sokobanpy/sokobanpy.py For Brython The Python file sokobanpy.py can be used directly for Brython. Alternatively you can turn sokobanpy package into site-packages.brython.js for Brython by using brip . If brip is not installed, install it first: pip install brip Install sokobanpy using brip : brip install sokobanpy Now a new site-packages.brython.js is generated in current directory. Your Brython project's index.html would just need to add a line <script src=\"path/to/site-packages.brython.js\"></script> Usage For CPython and MicroPython from sokobanpy import Sokoban level_string = ( \"\" + \"##########\\n\" + \"# #\\n\" + \"# $ + #\\n\" + \"# #\\n\" + \"##########\\n\" ) game = Sokoban(level_string, undo_limit=256) while True: print(game) print(f\"nmove={game.nmove}, npush={game.npush}\") if game.is_solved(): print(\"Level Solved!\") break action = input(\"Player Action (w,a,s,d,u,q): \") if action == \"w\": game.move(Sokoban.UP) elif action == \"a\": game.move(Sokoban.LEFT) elif action == \"s\": game.move(Sokoban.DOWN) elif action == \"d\": game.move(Sokoban.RIGHT) elif action == \"u\": game.undo() elif action == \"q\": break There are more examples in examples directory.","title":"Home"},{"location":"#sokobanpy","text":"Documentation Sokoban in Python. Author: Quan Lin License: MIT","title":"sokobanpy"},{"location":"#what-is-sokoban","text":"Sokoban is a classic puzzle game where the player pushes boxes onto designated goal positions within a warehouse-like environment. The game is played on a grid, and each element is represented by a standard character: \"#\" : Wall \"@\" : Player (Sokoban) \"$\" : Box \".\" : Goal \"*\" : Box on a goal \"+\" : Player on a goal \" \" : Empty space","title":"What is Sokoban?"},{"location":"#objective","text":"Move all boxes ( \"$\" ) onto the goal positions ( \".\" ) using the player ( \"@\" ). Boxes can only be pushed (not pulled), and only one box can be pushed at a time. The player cannot move through walls or boxes.","title":"Objective"},{"location":"#how-to-play","text":"Use directional controls to move the player. Strategically plan moves to avoid pushing boxes into corners or against walls where they can't be retrieved. The puzzle is solved when all boxes are on goal tiles ( \"*\" ).","title":"How to play"},{"location":"#installation","text":"","title":"Installation"},{"location":"#for-cpython","text":"pip install sokobanpy","title":"For CPython"},{"location":"#for-micropython","text":"If mpremote is not installed, install it first: pip install mpremote Install sokobanpy using mpremote : mpremote mip install github:jacklinquan/sokobanpy/sokobanpy/sokobanpy.py","title":"For MicroPython"},{"location":"#for-brython","text":"The Python file sokobanpy.py can be used directly for Brython. Alternatively you can turn sokobanpy package into site-packages.brython.js for Brython by using brip . If brip is not installed, install it first: pip install brip Install sokobanpy using brip : brip install sokobanpy Now a new site-packages.brython.js is generated in current directory. Your Brython project's index.html would just need to add a line <script src=\"path/to/site-packages.brython.js\"></script>","title":"For Brython"},{"location":"#usage","text":"","title":"Usage"},{"location":"#for-cpython-and-micropython","text":"from sokobanpy import Sokoban level_string = ( \"\" + \"##########\\n\" + \"# #\\n\" + \"# $ + #\\n\" + \"# #\\n\" + \"##########\\n\" ) game = Sokoban(level_string, undo_limit=256) while True: print(game) print(f\"nmove={game.nmove}, npush={game.npush}\") if game.is_solved(): print(\"Level Solved!\") break action = input(\"Player Action (w,a,s,d,u,q): \") if action == \"w\": game.move(Sokoban.UP) elif action == \"a\": game.move(Sokoban.LEFT) elif action == \"s\": game.move(Sokoban.DOWN) elif action == \"d\": game.move(Sokoban.RIGHT) elif action == \"u\": game.undo() elif action == \"q\": break There are more examples in examples directory.","title":"For CPython and MicroPython"},{"location":"api/","text":"API Reference sokobanpy Sokoban in Python Author: Quan Lin License: MIT sokobanpy.SokobanVector Represents a position or directional offset on a Sokoban board. Encapsulates a 2D coordinate (row and column) and supports vector-style operations like addition, subtraction, negation, equality, and hashing. Attributes: r ( int ) \u2013 Row index of the position. c ( int ) \u2013 Column index of the position. sokobanpy . SokobanVector . __init__ ( r , c ) Initialize a SokobanVector instance. Parameters: r ( int ) \u2013 Row index or row component of a direction vector. c ( int ) \u2013 Column index or column component of a direction vector. sokobanpy . SokobanVector . __repr__ () Return a human-readable string representation. Returns: str \u2013 String in the form SokobanVector(r=<row>, c=<col>) . sokobanpy . SokobanVector . __add__ ( other ) Add two SokobanVector vectors element-wise. Parameters: other ( SokobanVector ) \u2013 Another position or offset. Returns: SokobanVector \u2013 New instance whose row and column are the sums. Raises: TypeError \u2013 If other is not a SokobanVector instance. sokobanpy . SokobanVector . __sub__ ( other ) Subtract another SokobanVector from this SokobanVector. Parameters: other ( SokobanVector ) \u2013 Another position or offset. Returns: SokobanVector \u2013 New instance whose row and column are the results. Raises: TypeError \u2013 If other is not a SokobanVector instance. sokobanpy . SokobanVector . __neg__ () Invert this vector (negate both row and column). Returns: SokobanVector \u2013 New instance with both components negated. sokobanpy . SokobanVector . __eq__ ( other ) Check equality by comparing row and column. Parameters: other ( object ) \u2013 Object to compare. Returns: bool \u2013 True if other is a SokobanVector with the same r and c. sokobanpy . SokobanVector . __hash__ () Compute a hash so positions can be used in sets and dict keys. Returns: int \u2013 Hash of the (row, column) tuple. sokobanpy.Sokoban Sokoban puzzle game representation and logic. This class manages the game board, including walls, goals, boxes, and the player, and supports loading levels, rendering the board, executing moves, undoing moves, and checking for a solved state. Attributes: player ( SokobanVector ) \u2013 Current player position. walls ( set [ SokobanVector ] ) \u2013 Positions of walls. goals ( set [ SokobanVector ] ) \u2013 Positions of goals. boxes ( set [ SokobanVector ] ) \u2013 Positions of boxes. nrow ( int ) \u2013 Number of rows in the level. ncol ( int ) \u2013 Number of columns in the level. nmove ( int ) \u2013 Number of moves made. npush ( int ) \u2013 Number of box pushes made. history ( deque ) \u2013 Move history for undo. undo_limit ( int | None ) \u2013 Maximum undo history size. sokobanpy . Sokoban . __init__ ( level_string = DEFAULT_LEVEL_STRING , undo_limit = None ) Initialize Sokoban from a level string. Parses the given level_string into the internal state and sets an optional undo limit. Parameters: level_string ( str , default: DEFAULT_LEVEL_STRING ) \u2013 Multi-line string defining the initial board layout. undo_limit ( int | None , default: None ) \u2013 Maximum number of moves to store for undo; None for unlimited. sokobanpy . Sokoban . __str__ () Return a string representation of the current board. sokobanpy . Sokoban . to_grid () Render the current game state as a 2D grid of characters. Returns: \u2013 list[list[str]]: 2D array representing the board layout. sokobanpy . Sokoban . covers ( position ) Check if a position is within board bounds. Parameters: position ( SokobanVector ) \u2013 Position to check. Returns: bool \u2013 True if position is on the board; False otherwise. sokobanpy . Sokoban . can_move ( direction ) Return whether the player can move in the given direction. Parameters: direction ( SokobanVector ) \u2013 Direction vector. Returns: bool \u2013 True if move is legal; False otherwise. sokobanpy . Sokoban . move ( direction ) Move the player in a direction, pushing a box if necessary. Parameters: direction ( SokobanVector ) \u2013 Direction vector. Returns: bool \u2013 True if move executed; False if illegal. sokobanpy . Sokoban . undo () Undo the last move, restoring previous positions. Returns: bool \u2013 True if an undo was performed; False if no history. sokobanpy . Sokoban . is_solved () Check if all boxes are on goal positions. Returns: bool \u2013 True if the puzzle is solved; False otherwise. sokobanpy . Sokoban . find_path ( target_pos ) Find a path of empty spaces from the player to target using BFS. Parameters: target_pos ( SokobanVector ) \u2013 Destination position. Returns: \u2013 list[SokobanVector] | None: Sequence of positions to move through, or None if unreachable.","title":"API Reference"},{"location":"api/#api-reference","text":"","title":"API Reference"},{"location":"api/#sokobanpy","text":"Sokoban in Python Author: Quan Lin License: MIT","title":"sokobanpy"},{"location":"api/#sokobanpy.SokobanVector","text":"Represents a position or directional offset on a Sokoban board. Encapsulates a 2D coordinate (row and column) and supports vector-style operations like addition, subtraction, negation, equality, and hashing. Attributes: r ( int ) \u2013 Row index of the position. c ( int ) \u2013 Column index of the position.","title":"SokobanVector"},{"location":"api/#sokobanpy.SokobanVector.__init__","text":"Initialize a SokobanVector instance. Parameters: r ( int ) \u2013 Row index or row component of a direction vector. c ( int ) \u2013 Column index or column component of a direction vector.","title":"__init__"},{"location":"api/#sokobanpy.SokobanVector.__repr__","text":"Return a human-readable string representation. Returns: str \u2013 String in the form SokobanVector(r=<row>, c=<col>) .","title":"__repr__"},{"location":"api/#sokobanpy.SokobanVector.__add__","text":"Add two SokobanVector vectors element-wise. Parameters: other ( SokobanVector ) \u2013 Another position or offset. Returns: SokobanVector \u2013 New instance whose row and column are the sums. Raises: TypeError \u2013 If other is not a SokobanVector instance.","title":"__add__"},{"location":"api/#sokobanpy.SokobanVector.__sub__","text":"Subtract another SokobanVector from this SokobanVector. Parameters: other ( SokobanVector ) \u2013 Another position or offset. Returns: SokobanVector \u2013 New instance whose row and column are the results. Raises: TypeError \u2013 If other is not a SokobanVector instance.","title":"__sub__"},{"location":"api/#sokobanpy.SokobanVector.__neg__","text":"Invert this vector (negate both row and column). Returns: SokobanVector \u2013 New instance with both components negated.","title":"__neg__"},{"location":"api/#sokobanpy.SokobanVector.__eq__","text":"Check equality by comparing row and column. Parameters: other ( object ) \u2013 Object to compare. Returns: bool \u2013 True if other is a SokobanVector with the same r and c.","title":"__eq__"},{"location":"api/#sokobanpy.SokobanVector.__hash__","text":"Compute a hash so positions can be used in sets and dict keys. Returns: int \u2013 Hash of the (row, column) tuple.","title":"__hash__"},{"location":"api/#sokobanpy.Sokoban","text":"Sokoban puzzle game representation and logic. This class manages the game board, including walls, goals, boxes, and the player, and supports loading levels, rendering the board, executing moves, undoing moves, and checking for a solved state. Attributes: player ( SokobanVector ) \u2013 Current player position. walls ( set [ SokobanVector ] ) \u2013 Positions of walls. goals ( set [ SokobanVector ] ) \u2013 Positions of goals. boxes ( set [ SokobanVector ] ) \u2013 Positions of boxes. nrow ( int ) \u2013 Number of rows in the level. ncol ( int ) \u2013 Number of columns in the level. nmove ( int ) \u2013 Number of moves made. npush ( int ) \u2013 Number of box pushes made. history ( deque ) \u2013 Move history for undo. undo_limit ( int | None ) \u2013 Maximum undo history size.","title":"Sokoban"},{"location":"api/#sokobanpy.Sokoban.__init__","text":"Initialize Sokoban from a level string. Parses the given level_string into the internal state and sets an optional undo limit. Parameters: level_string ( str , default: DEFAULT_LEVEL_STRING ) \u2013 Multi-line string defining the initial board layout. undo_limit ( int | None , default: None ) \u2013 Maximum number of moves to store for undo; None for unlimited.","title":"__init__"},{"location":"api/#sokobanpy.Sokoban.__str__","text":"Return a string representation of the current board.","title":"__str__"},{"location":"api/#sokobanpy.Sokoban.to_grid","text":"Render the current game state as a 2D grid of characters. Returns: \u2013 list[list[str]]: 2D array representing the board layout.","title":"to_grid"},{"location":"api/#sokobanpy.Sokoban.covers","text":"Check if a position is within board bounds. Parameters: position ( SokobanVector ) \u2013 Position to check. Returns: bool \u2013 True if position is on the board; False otherwise.","title":"covers"},{"location":"api/#sokobanpy.Sokoban.can_move","text":"Return whether the player can move in the given direction. Parameters: direction ( SokobanVector ) \u2013 Direction vector. Returns: bool \u2013 True if move is legal; False otherwise.","title":"can_move"},{"location":"api/#sokobanpy.Sokoban.move","text":"Move the player in a direction, pushing a box if necessary. Parameters: direction ( SokobanVector ) \u2013 Direction vector. Returns: bool \u2013 True if move executed; False if illegal.","title":"move"},{"location":"api/#sokobanpy.Sokoban.undo","text":"Undo the last move, restoring previous positions. Returns: bool \u2013 True if an undo was performed; False if no history.","title":"undo"},{"location":"api/#sokobanpy.Sokoban.is_solved","text":"Check if all boxes are on goal positions. Returns: bool \u2013 True if the puzzle is solved; False otherwise.","title":"is_solved"},{"location":"api/#sokobanpy.Sokoban.find_path","text":"Find a path of empty spaces from the player to target using BFS. Parameters: target_pos ( SokobanVector ) \u2013 Destination position. Returns: \u2013 list[SokobanVector] | None: Sequence of positions to move through, or None if unreachable.","title":"find_path"}]}